from .System import *

'''

    I am using "# type: ignore" in a couple of places in here, to disable some annoying errors - I don't entirely like doing this, as I'm guessing it might disable errors I would want to see as well as ones I don't want to see.

'''

'''

    Note that, for now, it is assumed that the parameters of NoiseSources do not change, and so do not need to appear in "reset" - this is something that should be changed.

'''


# a NoiseSource is a kind of plugin object which can be attached to or incorporated into other objects
class NoiseSource(System):
    """
        The abstract superclass for all classes representing sources of noise.
    """

    # construct noise source
    def __init__(self):
        """
            __init__()

            Initialise NoiseSource.
        """
        super().__init__()
        self.noise = 0.0
        self.noises = [self.noise]

    # when stepped, a noise source generates a noise signal. this is where that signal gets stored for later analysis
    def step(self, dt: float) -> float: # type: ignore
        """
            Step the noise source forwards in time, and generate a noise output.

            :param dt: Interval of time to integrate the noise source over - not currently used.
            :type dt: float

            :return: The noise source's output.
            :rtype: float
        """
        self.noises.append(self.noise)
        return self.noise

    def reset(self) -> None:
        """
            Reset NoiseSource, by resetting noise level to 0 and deleting any existing history of noise outputs.
        """
        self.noise = 0.0
        self.noises = [self.noise]

    def get_data(self) -> Dict[str, List[float]]:
        """
            Get the noise source's data.

            :return: The noise source's data.
            :rtype: dict of data, which only includes the history of noise outputs in this superclass.
        """

        n = self.noises
        return {"noises": n}

# a white noise source. in every simulation step, the noise will take any value in the specified interval
#   note that white noise can often be filtered quite easily
class WhiteNoiseSource(NoiseSource):
    """
        A class representing a source of white noise. In every simulation step, the noise source outputs a random value drawn from a uniform distribution, the limits of which are set when the noise source is constructed.

        .. figure:: images/WhiteNoiseSource.svg
          :width: 400
          :align: center
          :alt: White noise
    """

    # construct white noise source which will generate noise in the interval [min_val, max_val]
    def __init__(self, min_val: float, max_val: float):
        """
            __init__(min_val, max_val)

            Construct instance of :class:`WhiteNoiseSource`. The noise generated by the noisesource will lie between ``min_val`` and ``max_val``.

            :param min_val: The minimum value of the noise that this source will output.
            :type min_val: float

            :param max_val: The maximum value of the noise that this source will output.
            :type max_val: float

        """
        super().__init__() # type: ignore
        self.extent = max_val - min_val  # scale of the noise
        self.min_val = min_val  # minimum value noise will take (i.e. offset)

    # step noise
    def step(self, dt: float) -> float:
        """
            Step noise source forwards in time. For this class, all that involves is generating a new output value and updating its history.

            :param dt: Interval of time to integrate the noise source over - not currently used.
            :type dt: float

            :return: Output from noise source.
            :rtype: float
        """
        self.noise = self.min_val + (self.extent * np.random.random())  # generate noise
        return super().step(dt)  # call step of NoiseSource to store noise


# brown noise source. technically, brown noise is the integral of white noise, and it is named after Brownian motion
#   note that drift or brown noise can be quite challenging to detect and compensate for
class BrownNoiseSource(NoiseSource):
    """
        A class representing a source of brown noise, (e.g. a random walk like brownian motion). Technically, brown noise is the integral of white noise, so in each simulation step white noise is generated and then added to the noise level from the previous simulation step. This results in a drifting noise level.

        .. figure:: images/BrownNoiseSource.svg
          :width: 400
          :align: center
          :alt: Brown noise
    """
    # construct brown noise source. max_step_size is the maximum step in either positive or negative direction, i.e.
    # half the scale of the white noise
    def __init__(self, max_step_size: float):
        """
            __init__(max_step_size)

            Construct instance of :class:`BrownNoiseSource`.

            :param max_step_size: The maximum distance that the output of the :class:`BrownNoiseSource` will move by in a single simulation step.
            :type max_step_size: float
        """
        super().__init__()
        self.max_step_size = max_step_size

    # step noise source
    def step(self, dt: float) -> float:
        """
            Step noise source forwards in time. For this class, all that involves is generating a new output value and updating its history.

            :param dt: Interval of time to integrate the noise source over - not currently used.
            :type dt: float

            :return: Output from noise source.
            :rtype: float
        """
        self.noise += self.max_step_size * (2 * np.random.random() - 1)  # generate noise
        return super().step(dt)  # store noise


# a spike noise source generates positive or negative spikes in every simulation step, with the specified probability
# positive and negative spike sizes are specified independently (and either one could have size 0, if they are not
# wanted)
# the duration of a spike is a single simulation step, but as currently implemented nothing prevents two or more steps
# from occurring in a row, which is equivalent to a variable length spike (although this will be rare for low prob
# values)
#   note that this can be a very challenging kind of noise to handle for some controllers
class SpikeNoiseSource(NoiseSource):
    """
        A class representing a source of "spike" noise.

        .. figure:: images/SpikeNoiseSource.svg
          :width: 400
          :align: center
          :alt: Spike noise
    """
    # construct noise source
    def __init__(self, prob: float,
                 pos_size: float, neg_size: float):
        """
            __init__(prob, pos_size, neg_size)

            Construct a spike noise source. The sizes of positive and negative spikes are controlled independently. If you don't want to use either positive or negative spikes, just set the corresponding parameter to 0, but note that you might want to double the spike probability parameter to compensate for half of the spikes (on average) being 0.

            :param prob: The probability of a spike being emitted. When a spike is output, it will be either positive or negative with equal probability.
            :type prob: float

            :param pos_size: The size of a positive spike.
            :type pos_size: float

            :param neg_size: The size of a negative spike.
            :type neg_size: float
        """
        super().__init__()
        self.prob = prob  # probability of a spike
        self.pos_size = pos_size  # size of positive spike
        self.neg_size = neg_size  # size of negative spike

    # this was added for convenience, for use with SpikeNoiseDisturbanceSource, and is used to enable and disable the noise
    # - it does no real harm to do it this way, but it is not consistent with other the way the rest is coded
    #   in a future version this will be changed
    def set_params(self, params: List[float]) -> None:
        """
            A method for setting the noise source's parameters.

            :param params: The noise source's parameters, in the form ``[prob, pos_size, neg_size]``
            :type params: list(float)
        """
        self.prob = params[0]
        self.pos_size = params[1]
        self.neg_size = params[2]

    # step noise
    def step(self, dt: float) -> float:
        """
            Step noise source forwards in time. For this class, all that involves is generating a new output value and updating its history.

            :param dt: Interval of time to integrate the noise source over - not currently used.
            :type dt: float

            :return: Output from noise source.
            :rtype: float
        """
        self.noise = 0.0  # noise is zero by default
        if np.random.random() < self.prob:  # if a randomly generated number is less than the probability of a spike, then spike
            if np.random.random() < 0.5:  # spikes are positive or negative with equiprobability
                self.noise = self.pos_size  # positive spike
            else:
                self.noise = self.neg_size  # negative spike
        return super().step(dt)  # call step of NoiseSource to store noise


# in the real world, we might expect different types of noise to be superimposed, e.g. low level white noise, plus some
# drift (brown noise), and possibly the occasional big spike coming from somewhere
# this class provides a convenient way to have a single NoiseSource which incorporates all of those kinds of noise
class NoiseMaker(NoiseSource):
    """
        A subclass of :class:`NoiseSource` which provides a source of mixed noise: white, brown and "spike". A :class:`NoiseMaker` has its own instances of :class:`WhiteNoiseSource`, :class:`BrownNoiseSource` and :class:`SpikeNoiseSource`, and its output is the sum of their outputs.

        .. figure:: images/NoiseMaker.svg
          :width: 400
          :align: center
          :alt: Mixed noise
    """
    def __init__(self,
                 white_noise_params: List[float]=[0.0, 0.0],
                 brown_noise_step: float=0,
                 spike_noise_params: List[float]=[0.0, 0.0, 0.0]):
        """
            __init__(white_noise_params: List[float]=[0.0, 0.0], brown_noise_step: float=0, spike_noise_params: List[float]=[0.0, 0.0, 0.0])

            Construct :class:`NoiseMaker`. The noisemaker's individual noise sources will only be constructed if non-zero parameters for them are passed into ``__init__``. The :class:`NoiseMaker` class does not provide for this to be changed after construction, although additional noise sources can always be added to a noisemaker's list manually.

            :param white_noise_params: Parameters for the noisemaker's :class:`WhiteNoiseSource`. Defaults to [0, 0], in which case the noisemaker will
            :type white_noise_params: list(float)

            :param brown_noise_step:
            :type brown_noise_step: float

            :param spike_noise_params:
            :type spike_noise_params: list(float)

        """
        super().__init__()
        self.noise_sources: List[NoiseSource] = []  # list of noise sources
        if white_noise_params != [0, 0]:  # for each type of NoiseSource, it is only added to the list if it has non-zero parameters
            self.noise_sources.append(WhiteNoiseSource(max_val=white_noise_params[0], min_val=white_noise_params[1]))
        if brown_noise_step != 0:
            self.noise_sources.append(BrownNoiseSource(max_step_size=brown_noise_step))
        if spike_noise_params != [0, 0, 0]:
            self.noise_sources.append(SpikeNoiseSource(prob=spike_noise_params[0], pos_size=spike_noise_params[1], neg_size=spike_noise_params[2]))

    # step noisemaker
    def step(self, dt: float) -> float:
        """
            Step the :class:`NoiseMaker` forwards in time. All attached noise sources are stepp forwards, and then their outputs are summed to get the output from this noisemaker.

            :param dt: Interval of time to integrate the noise source over - not currently used.
            :type dt: float

            :return: Output from noise source.
            :rtype: float
        """
        self.noise = 0.0
        for noise_source in self.noise_sources:  # for all noise sources, effects are accumulated
            self.noise += noise_source.step(dt)  # accumulated noise may be positive or negative
        return super().step(dt)  # call NoiseSource step to store noise for later analysis

    def reset(self):
        for noise_source in self.noise_sources:
            noise_source.reset()
        super().reset()
